了解。いまの状況（Lichtblick/Electron 内に `antimatter15/splat` を移植済み・WebGL）を前提に、**iGPU前提で WebGPU に移行して “見た目を改善”**するための「目的→要件→実装計画」を、実務で使える形に整理します。

---

# 0. ゴール定義（何を“改善”したいのか）

WebGL版が「汚く見える」主因はだいたいこの3つに収束します。まずゴールをここに紐付けるのが最短です。

## 見た目の主要KPI（優先度順）

1. **にじみ/濁りを減らす**（α合成の破綻・順序近似・過密の副作用）
2. **floaters を“見えない”レベルに抑える**（寄与の小さいガウスの抑制）
3. **視点依存の色（SH）が効いた“質感”にする**（DCだけでなく f_rest を活かす）
4. iGPUでも **操作が破綻しないfps**（最低 20–30fps、理想 60fps）

> iGPU前提だと「完全な正確さ」より **“見た目が良い近似”**が勝ちます。

---

# 1. 非ゴール（やらないことを最初に切る）

iGPU + Electron で無理筋になりがちなものを先に排除します。

* ❌ 数千万ガウス（都市スケール）をそのまま
* ❌ 毎フレーム “全ガウス完全深度ソート”
* ❌ 物理的に正確な透過（厳密な order-independent transparency）

代わりに：

* ✅ **タイル単位の近似ソート**
* ✅ **強いpruning + LOD**
* ✅ **front-to-back + early termination の近似**

---

# 2. アーキテクチャ方針（WebGPU化で“何が変わるか”）

WebGPU化で本当に効くのは、「GPUで前処理できる」点です。

## WebGL（現状）

* 画面に投げてブレンドするだけ
* ソート・カリングは CPU/Worker で苦しい
* SHのフル評価は重くなりがち

## WebGPU（目標）

* **Compute で前処理**：投影・タイル振り分け・寄与評価・カリング
* **タイル内で並べ替え**：粗い深度ビン or 軽量ソート
* **Render で合成**：SH評価＋front-to-back合成（早期終了）

---

# 3. 実装計画（MVP→改善の順で積む）

あなたの状況だと、段階的に置き換えるのが最短です。

## Phase 1: WebGPU “表示”に切り替える（最小MVP）

**目的**：WebGPUパスをLichtblick上で安定稼働させる（性能は二の次）

* 入力：既存の `.splat` か `.ply` の読み込み部分は流用
* 出力：WebGPUで **同じ見た目を最低限再現**
* レンダリング：

  * ガウスをscreen-space楕円として描く（現状と同じ思想）
  * SHは **まずDCのみ**でOK（ここで詰まらないため）
* 成果：WebGPUのswapchain・リサイズ・カメラ操作が安定

**Done条件**

* iGPU環境でクラッシュしない
* WebGL版と同じモデルが表示できる

---

## Phase 2: “汚さ”の主因を潰す（ここが効く）

### 2-A) GPUカリング（floaters対策の主砲）

**目的**：floatersを「描かない」ことで消す

Computeで各ガウスについて：

* 視錐台外 → drop
* `opacity_sigmoid < α_min` → drop
* projected radius が小さすぎる → drop
* **importance**（例：α×投影面積）下位を drop

**UIにすると強い**

* `α_min` スライダ
* `importance percentile` スライダ（例：上位 60%だけ描画）

→ これだけで体感の“汚さ”が一気に減ります。

---

### 2-B) タイル分割＋粗い深度順（にじみ対策）

**目的**：α合成の破綻を減らす

完全ソートは諦め、タイルごとに：

* 深度を 8〜32ビン程度に量子化
* ビン順に front-to-back 合成
* early termination（透過が十分積み上がったら停止）

**iGPUに優しい**

* 厳密ソートより安い
* 見た目の改善効果が大きい

---

## Phase 3: SHを“本当に効かせる”（質感の最後の一押し）

**目的**：HFのSH（f_rest）を意味ある形で使う

iGPU前提の現実的設計：

* 近距離：SH degree 3
* 中距離：degree 1
* 遠距離：DCのみ

これをCompute側で LOD 判定して、Render側の負荷を抑えます。

**Done条件**

* DCだけの“ベタ塗り感”が減る
* 視点移動でハイライト/質感が変わる

---

## Phase 4: さらに快適に（任意）

* GPUメモリに乗り切らない場合のストリーミング
* タイルごとのGaussianリストをキャッシュ
* マルチフレームでソートを再利用（カメラ小移動時）

---

# 4. データ形式・入力の整理（PLY/ splat）

あなたは既に `splat` 移植済みなので、ここは戦略を決めるだけ。

## 選択肢

### A) `.splat`（バイナリ）に寄せる（おすすめ）

* 読み込み高速
* 転送量が少ない
* WebGPUに直でアップロードしやすい

### B) `.ply` をそのまま読む

* 互換性は高い
* ただしパースが重い（JSで辛い）
* 初回ロードが遅い

**実務では**
「PLY → 一度 `.splat` に変換してキャッシュ」が強いです（Lichtblickはローカルアプリなので特に）。

---

# 5. 成果物（あなたが“見たい”ものに直結する機能）

Lichtblick統合の価値は「可視化にデバッグ機能を足せる」ことなので、最低限これを入れると一気に強くなります。

## 必須UI（デバッグ価値が高い）

* α閾値（opacity cutoff）
* importance cutoff（上位何%描画）
* SH LOD（DC / deg1 / deg3）
* splat数表示（描画数・カリング数）
* fps / frame time 表示

これで「汚い原因」を数値で追えます。

---

# 6. iGPU前提の性能目標（現実的なライン）

iGPUは帯域が弱いので、目安は：

* 目標：**描画 200k〜800k splats**（モデルと解像度次第）
* 60fpsに固執しない：**30fps安定**をまず狙う
* 重要：**“描画する数を減らす”のが正義**（pruning/LOD）

